\section{Algoritmi di approssimazione}
In questa parte si introdurranno gli algoritmi di approssimazione, 
dopo aver accennato ad alcuni concetti preliminari legati alla complessità.
Si defineranno in particolari classi di problemi, e si definiranno alcune 
tecniche note nella risoluzione di problemi di ottimizzazione.

\subsection{Classi di complessità}
Partiamo dalla definizione di algoritmo, per poi arrivare a definire le classi
di complessità note.

\paragraph{Algoritmo}
Un algoritmo per un problema $\Pi$ può essere visto come una \emph{balck-box}
che verrà indicata con $A$, che opera come segue: \\
dato un input $x \in I_{\Pi}$, l'algoritmo $A$ produrrà un output 
$y \in O_{\Pi}$, tale che $y \in Sol_{\Pi}(x)$.

\subsubsection{Complessità algoritmica}
La complessità algoritmica è lo studio del dispendio di risorse di 
un algoritmo.\\
Un esempio è il tempo: $T_a : I_\Pi \rightarrow \mathbb{N}$, possiamo passare
in una notazione $t_a : \mathbb{N} \rightarrow \mathbb{N}$ dove il dominio è 
la lunghezza di input, in quel caso si avrà che $t_a(n) : \max\{ T_a(n),\; x \in I_{\Pi},\; |x| = n\}$

Date due soluzioni, è preferibile quella asintoticamente minima, 
più formalmente, quella a numeratore tale che $\lim_{x \to \infty} \frac{t_1}{t_2} = \infty $.

\subsubsection{Complessità strutturale}
Si definiscono ora due classi di problemi, \emph{P} e \emph{NP}, per 
poi introdurre i concetti di \emph{riducibilità polinomiale} e di \emph{NP-completezza}.

\paragraph{Classe P}
La classe \emph{P} corrisponde ai problemi decisionali 
per cui esiste un algoritmo che opera
in tempo polinomiale, ovvero: 
$$P = \{\Pi\;|\;\Pi\;decisionale, \; \exists\;A\;per\;\Pi,\;t.c.\;t_a(n)\;=\;O(Polinomio)\}$$

\paragraph{Classe NP}
La classe \emph{NP} corrisponde ai problemi decisionali 
per cui esiste un algoritmo che opera
in tempo polinomiale su una macchina non deterministica, ovvero: 
\begin{equation}
    \begin{aligned}
        NP = \{\Pi\;|\;\Pi\;decisionale, \; \exists\;A\;per\;\Pi,\; t.c.\;t_a(n)\;=\;O(Polinomio)\;
        \\su\;una\;macchina\;non\;deterministica\}
    \end{aligned}
\end{equation}

\paragraph{Riducibilità polinomiale}
Un problema si dice riducibile polinomialmente se esiste un mapping del suo 
input in un input per un algoritmo polinomiale, ovvero:
$$\Pi_1 \leqslant _p \Pi_2 \;sse\; \exists f : 2^* \rightarrow 2^*\; t.c$$
\begin{enumerate}
    \item $f$ è calcolabile in tempo polinomiale
    \item $\forall x \in I_{\Pi1},\;f(x) \in I_{\Pi2},\; Sol_{\Pi1}(x) = Sol_{\Pi2}(f(x))$ 
\end{enumerate}

\paragraph{NP completezza}
Un problema $\Pi$ è NP completo sse $\forall\;\Pi^\prime \in NP,\; \Pi^\prime \leqslant _p \Pi, \; \Pi \in NP$.
Ovvero se ogni problema in NP è riducibile polinomialmente al problema che si sta 
considerando.

\begin{theorem}
    SAT è NP completo.
\end{theorem}
\begin{corollary}
    Se $\Pi_1 \leqslant _p \Pi_2$ e $\Pi_1$ è NP completo, allora $\Pi_2$ è NP completo.
\end{corollary}
\begin{proof}
    $\Pi^\prime \in NP, \Pi^\prime \leqslant _p \Pi_1 \leqslant _p \Pi_2$, quindi $\Pi_2$ è NP completo.
\end{proof}
\begin{remark}
    Se trovassi un problema $\Pi$ NP completo t.c, $\Pi^\prime \leqslant _p \Pi$, 
    allora \emph{P=NP}.
\end{remark}

\subsection{Problemi di ottimizzazione}
Nella definizione di un problema di ottimizzazione bisogna tenere conto dei 
seguenti parametri:
\begin{enumerate}
    \item Insieme di input $I_\Pi$
    \item Insieme di output $O_\Pi$
    \item $F_\Pi : I_\Pi \rightarrow 2^{O_\Pi} \setminus \{\emptyset\}$, $F_\Pi(x)$ indica 
    le soluzioni accettabili per l'input $x$
    \item $C_\Pi : I_\Pi \times O_\Pi \rightarrow \mathbb{Q}^{>0}$, funzione obiettivo, 
    con $C_\Pi(x,y)$ si indica il valore della funzione obiettivo per l'input \emph{x}, con soluzione $y \in O_\Pi$
    \item $t_\Pi \in \{min, \;max\}$, ovvero il criterio del problema.
\end{enumerate}
\begin{remark}
    $Sol(x) = \{y^* \in O_\Pi | y^* \in F_\Pi, \forall y^\prime \in F_\Pi, c(x, y^*) \leqslant (\geq ) c(x, y^\prime)\}$
\end{remark}
\paragraph{Problema di decisione associato}
Dato un problema di ottimizzazione $\Pi$ esiste un problema di decisione associato $\hat{\Pi}$.
\\L'idea è quella di considerare un input del problema originale e un costo alla soluzione, e rispondere
in base all'esistenza di una soluzione con quel costo.\\
In particolare: $$I_{\hat{\Pi}} = I_\Pi \times \mathbb{Q}^{>0}$$ 
$$(x, \theta) = C_\Pi(x, y^*(x)) \leqslant (\geq ) \theta$$

\subsubsection{Classi di ottimizzazione}
\paragraph{PO}

\paragraph{NPO}

% \subsection{Tecniche greedy}
% \subsubsection{Load balancing}
% \subsubsection{Center selection}
% \subsubsection{Inapprossimabilità di center selection}
% \subsubsection{Set cover}
% \subsection{Tecnica di pricing}
% \subsubsection{Vertex cover}
% \subsubsection{Disjoint paths}
% \subsection{Tecniche basate sull'arrotondamento}
% \subsubsection{Vertex cover mediante arrotondamento}
% \subsection{Altri esempi}
% \subsubsection{Travel Salesman Problem metrico}
% \subsubsection{Inapprossimabilità del TSP}
% \subsection{Schemi di approssimazione in tempo polinomiale e pienamente polinomiale}
% \subsubsection{Minimum partition PTAS}
% \subsubsection{Knapsack FPTAS}