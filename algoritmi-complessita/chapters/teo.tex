\section{Teoria della complessità di approssimazione}

In questa sezione si affrontano alcune tematiche, in particolare il teorema PCP, 
con il quale di riuscirà a dimostrare l'inapprossimabilità di MaxEkSat e Indipendent set.

\subsection{Verificatori}
Il concetto di verificatore assume diverse sfaccettature nel corso 
delle sezioni che seguono, ma sostanzialmente è una macchina che si occupa di verificare 
la decisione di un certo problema per un certo input.

\subsubsection{NP attravero testimoni}
Una Macchina di Turing verificatore per un problema di decisione $L \subseteq 2^*$, riceve due input, $x$ e $w$, testimone, 
e si comporta come segue:
\begin{enumerate}
    \item se $x \notin L$ risponde no qualunque sia $w$
    \item se $x \in L$, allora $\exists w\in 2^*$ tale che la macchina risponde sì
\end{enumerate}
Devono valere però:
\begin{enumerate}
    \item $|w| \leq P(|x|)$ ovvero la lunghezza di $w$ è polinomiale nell'input
    \item la macchina lavora in tempo polinomiale
\end{enumerate}

\begin{remark}
    Si può pensare alla classe NP come una classe di problemi facilmente verificabili, ma difficilmente 
    risolvibili.
\end{remark}
\begin{remark}
    Esistono problemi nè risolvibili nè  verificabili facilmente.
\end{remark}
\begin{theorem}
    Un problema $L \subseteq 2^* \in $NP se e solo se esiste una Macchina di Turing deterministica $V$, verificatore,
    e un polinomio $P()$, tali che:
    \begin{enumerate}
        \item $V(x,w)$ lavora in tempo polinomiale in $|x|$
        \item $\forall x \in 2^*$:
        \begin{enumerate}
            \item se $x \in L$, $\exists w \in 2^*$ tale che $|w| \leq P(|x|)$ e $V(x,w) = \mathit{yes}$
            \item se $x \notin L$, $\forall w \in 2^*$ $|w| \leq P(|x|)$, $V(x,w) = \mathit{no}$
        \end{enumerate}
    \end{enumerate}
\end{theorem}

\subsubsection{NP con oracolo}
L'idea di una Macchina di Turing con oracolo presuppone l'esistenza, oltre 
al nastro classico, di un nastro dell'oracolo.

La Macchina può entrare in uno stato di query all'oracolo, 
in cui lo interroga e l'oracolo risponderà, facendole cambiare stato di conseguenza.

\begin{theorem}
    Un problmema $L \subseteq 2^* \in $ NP se esiste una Macchina di Turing con oracolo $V$ e
    un polinomip $P()$, tale che:
    \begin{enumerate}
        \item $V(x)$ lavora in tempo polinomiale in $|x|$
        \item $V(x)$ effettua al più $P(|x|)$ query all'oracolo
        \item $\forall x \in 2^*$:
        \begin{enumerate}
            \item se $x \notin L$, $V(x) = no$ qualunque sia l'oracolo
            \item se $x \in L$, $V(x) = yes$ per una qualche stringa dell'oracolo
        \end{enumerate}
    \end{enumerate}
\end{theorem}

\subsubsection{Verificatore probabilistico}
In questo caso si estende il concetto di verificatore con 
oracolo aggiungendo un nastro di numero casuali che la Macchina può leggere.

Date due funzioni 
$$q,r : \mathbb{N} \longrightarrow \mathbb{N}$$
$PCP[r,q]$ è la classe di linguaggi $L \subseteq 2^*$ per i quali esiste un verificatore probabilistico
con le seguenti proprietà: 
\begin{enumerate}
    \item $V(x)$ lavora in tempo polinomiale
    \item $V(x)$ fa al massimo $q(|x|)$ query all'oracolo
    \item $V(x)$ usa al più $r(|x|)$ bit casuali
    \item $\forall x \in 2^*$:
    \begin{enumerate}
        \item Se $x \notin L$, $V(x) = no$ con probabilità $\geq \frac{1}{2}$
        \item Se $x \in L$, $V(x) = yes$ con probabilità $1$ per almeno
        un $w \in 2^*$
    \end{enumerate}
\end{enumerate}

\begin{remark}
    Vale che:
    \begin{itemize}
        \item $NP = PCP[0,\mathit{Poly}] = \cup_{p : \mathit{polinomio}}PCP[0, p]$ 
        \item $P = PCP[0,0]$
    \end{itemize}
\end{remark}

\subsubsection{Teorema PCP}
Definiti i verificatori probabilistici, si passa ora al teorema PCP, 
che in un certo senso dice che il non determinismo può essere portato ad una costante, 
che fa quindi un numero costante di interrogazioni all'oracolo, 
a patto che si facciano una quantità logaritmica di scelte casuali.

\begin{theorem}
    $PCP[O(\log n), O(1)] = NP$
\end{theorem}

\subsubsection{Verificatore NP in forma canonica}
Si considera ora la classe 
$$PCP[r(n), q], r(n) = O(\log n), q \in \mathbb{N}$$
Un verificatore facente parte di questa classe, può leggere 
fino a $r(|x|)$ bit random, e $q$ query all'oracolo.

Il processo seguito da un verificatore del genere è quello 
di interrogare l'oracolo e agire di conseguenza.
In particolare, si può pensare a un albero contenente le varie strade che può prendere 
il verificatore in base alla risposta dell'oracolo. Ha quindi un comportamento 
adattivo.

Quello che può fare però il verificatore, invece che chiedere di volta in volta 
all'oracolo, è simulare tutti i rami di decisione, e segnarsi quando dovrebbe 
interrogarlo, in modo da poi richiedere in una volta sola tutto quello di 
cui ha bisogno.

Un verificatore in forma canonica è proprio questo, ovvero un verificatore che prima
simula tutti i rami di computazione possibili, che variano in base all'interrogazione
all'oracolo, per poi interrogarlo su tutte le posizioni di cui ha bisogno.\\
Il verificatore così ottenuto può essere considerato come una semplice Macchina di Turing, 
infatti non deve più interrogare l'oracolo.

\subsection{Problemi inapprossimabili}
In questa sezione si affrontano due dimostrazioni di inapprossimabilità, 
esse sfruttano i concetti introdotti a sezione precedente.

\subsubsection{Inapprossimabilità MaxEeSat}
Il problema è stato introdotto a sezione \ref{eksat}, e si era individuato un algoritmo 
deterministico che sfruttava concetti probabilistici.

\begin{theorem}
    Esiste un algoritmo deterministico che approssima MaxE3Set con tasso
    $\frac{8}{7}$
\end{theorem}

\begin{theorem}
    \label{th1ek}
    Esiste un $\bar{\epsilon} > 0$ tale che MaxE3Sat non è $(\frac{8}{7}-\bar{\epsilon})$-approssimabile. 
\end{theorem}

Un versione rilassata del teorema appena introdotto è la seguente.
\begin{theorem}
    Esiste un $\bar{\epsilon} > 0$ tale che MaxE3Sat non è $(1+\bar{\epsilon})$-approssimabile. 
\end{theorem}

\begin{remark}
    Il teorema \ref{th1ek} dimostra che l'algoritmo individuato a sezione \ref{eksat} è ottimo, 
    mentre quello successivo che MaxE3Sat non fa parte di PTAS. La dimostrazione di quest'ultimo è
    molto più semplice e usa lo stesso principio.
\end{remark}

Considerando quanto detto su PCP a sezione precedente: 
$$L \in NP \implies \exists r(n) \in O(\log n), \exists w \in \mathbb{N}, L \in PCP[r(n), q]$$



% \subsubsection{Inapprossimabilità Max Indipendent Set}
